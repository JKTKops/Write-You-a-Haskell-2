# CDoc

The `CDoc` type is a wrapper on `Doc` from the `pretty` package. It lives, along with the rest of the pretty-printing stuff, in `Utils.Outputable`.

As a reminder, `CDoc` exists so that we can produce relevant error messages by knowing information about the compilation settings. Additionally, given the same settings, we may want to print the same `CDoc` in various styles. For example, we may want an AST to be pretty-printed one way for viewing in GHCi, and another way when producing compiler dumps.

That means we want to carry a _context_ with our `Doc`. So let's make it a function type!

```haskell
newtype CDoc { runCDoc :: CDocContext -> Pretty.Doc }

data CDocContext = CDocContext
     { cdocStyle    :: !CDocStyle
     , cdocSettings :: !Settings
     }
```

Some styles we might want include
1. User Style. Print nice messages, maybe including some nicely formatted code. Part of keeping messages nice means limiting how long they are.
2. Debug Style. Print _all_ the debugging output.
3. Dump Style. Less information than debug style, but more than user style.
4. Code Style. Print code generated by a code generator.

There's no reason to do anything fancy here. We can just encode these styles into one type:

```haskell
data CDocStyle
     = UserStyle Depth
     | DebugStyle
     | DumpStyle
     | CodeStyle CodeStyle

data Depth = FullDepth
           | PartialDepth Int
data CodeStyle = CStyle    -- still don't know which we're targetting
               | JavaStyle
```

These types form the core of all the pretty printing the compiler can do. For extra prettiness, we could also support colors using ANSI terminal escape codes. Take it as an exercise or see the source for the chapter.

### Basic Combinators

The challenge with creating wrapper types like `CDoc` is that all the functions from `Text.PrettyPrint` that we were taking advantage of before are now no longer compatible. The most annoying way to fix this is to write functions like
```haskell
parens :: CDoc -> CDoc
parens d = CDoc $ \ctx -> Pretty.parens $ runCDoc d ctx
```
for every single `Pretty` function we care about.

This is a functional language. We're not about that life.

Instead, we can write a couple of "wrapper" functions and demand that GHC inline them.
```haskell
wrapper :: (Pretty.Doc -> Pretty.Doc) -> (CDoc -> CDoc)
wrapper f = \d -> CDoc $ f . runCDoc d
{-# INLINE wrapper #-}
```
Notice what appears to be a redundant lambda in the definition. GHC's inliner is very nice in that it trusts us. It will inline exactly the function we wrote, regardless of any optimizations that are applied separately. It will also only inline functions that are fully applied. In this case, that's bad, because we really do want it to be inlined when it is applied to only the function argument. By writing the function this way, we can "trick" GHC into doing what we want. This trick is described in a bit more detail in [GHC's User Guide](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#inline-and-noinline-pragmas).

Exercise: implement
```haskell
wrapper2 :: (Pretty.Doc -> Pretty.Doc -> Pretty.Doc)
         -> (CDoc -> CDoc -> CDoc)

listWrapper :: ([Pretty.Doc] -> Pretty.Doc) -> [CDoc] -> CDoc
```

The full list of functions that we want to bring over, for now, is at [^1].
We can also export a bunch of small, frequently used documents by name, rather than writing `text "->"` all over the code. For example,
```haskell
semi   = char ';'
dcolon = text "::"
vbar   = char '|'
```
and more. A suggested list of these is at [^2].

At this point, `CDoc` has all the combinators we originally wanted from `Doc`.

### `CDoc` Specific Combinators

Of course, the entire point of _creating_ `CDoc` was to get access to the context. So we can add a collection of combinators for doing just that.

The most common type of combinator we want is one that gives us direct access to a field of the context. For example, suppose we have a command-line flag that suppresses printing of `Uniques` (perhaps the user is reading some `Core`). GHC does have such a flag. Then the `Outputable` instance for `Name` would have to look more like this:
```haskell
instance Outputable Name where
    ppr Name{n_occ=name, n_uniq=uniq} =
        cdocWithSettings $ \stngs ->
            ppr name <> if gOpt FSuppressUniques stngs
                        then empty
                        else ppr uniq
```

exercise: implement
```haskell
cdocWithSettings :: (Settings -> CDoc) -> CDoc
cdocWithStyle    :: (CDocStyle -> CDoc) -> CDoc
```

We will expose `cdocWithSettings`, but not `cdocWithStyle`. `CDocStyle` abstracts over some things that we don't want to see when creating `CDoc`s, namely, the depth. But later we will also abstract over more information, like what the color scheme is and some functions for deciding how to qualify a given name. But we can expose some accessors for getting _some_ information from the style.

```haskell
withIsDebugStyle :: (Bool -> CDoc) -> CDoc
withIsDebugStyle f = withCDocStyle $ f . isDebugStyle
```

And using that we can implement some basic (and _very_ useful) combinators:

```haskell
ifDebugStyle :: CDoc -> CDoc -> CDoc
ifDebugStyle yes no = withIsDebugStyle $ \b -> if b then yes else no

whenDebugStyle :: CDoc -> CDoc
whenDebugStyle d = ifDebugStyle d empty
```

We're not neglecting `DumpStyle` here. `DebugStyle` is the "print literally everything" style, and we expect it to print lots of information that we really don't want in the dump output. `DumpStyle`, on the other hand, is currently "`UserStyle` but always `FullDepth`." Later, it will be "`UserStyle` but always `FullDepth`, `Uncolored`, with `alwaysQualify`." `DebugStyle` is `DumpStyle`, but with all the extra bits and pieces added via `withIsDebugStyle`.

For testing in GHCi it's often useful to override the style for a doc. For that we have a couple of setters:

```haskell
setCDocStyle :: CDocStyle -> CDoc -> CDoc
setCDocStyle style d = CDoc $ \ctx -> runCDoc d ctx{cdocStyle = style}

cdocSetDepth :: Depth -> CDoc -> CDoc
cdocSetDepth depth d = CDoc $ \ctx -> case ctx of
    CDocContext{cdocStyle = UserStyle{}} ->
        runCDoc d ctx{cdocStyle = UserStyle depth
    _ -> runCDoc d ctx

setCDocSettings :: Settings -> CDoc -> CDoc
setCDocSettings = -- very easy exercise
```

Then we need the combinators for printing with depth. There are two reasons we might use depth in a `CDoc`.
1. We're printing a large tree, and want to limit how much detail is shown. This could happen if there is a typechecking error in derived code.
2. We're printing a list, and want to limit how many things are shown.

```haskell
cdocDeeper :: CDoc -> CDoc
cdocDeeper d = CDoc $ \ctx -> case ctx of
    CDocContext{cdocStyle = UserStyle (PartialDepth 0)} -> Pretty.text "..."
    CDocContext{cdocStyle = UserStyle (PartialDepth n)} -> 
        runCDoc d ctx{cdocStyle = UserStyle (PartialDepth (n - 1))}
    _ -> runCDoc d ctx

-- there are many ways to render [CDoc] into CDoc, so don't
-- force a choice of one of them here.
cdocDeeperList :: ([CDoc] -> CDoc) -> [CDoc] -> CDoc
cdocDeeperList f ds
  | null ds   = f []
  | otherwise = CDoc work
  where work ctx@CDocContext{cdocStyle = UserStyle (PartialDepth n)}
          | n == 0    = Pretty.text "..."
          | otherwise = runCDoc (f (go 0 ds))
			              ctx{cdocStyle = UserStyle (PartialDepth (n - 1))}
		  where go _ [] = []
		        go i (d:ds)
		          | i >= n    = [text "..."]
		          | otherwise = d : go (i+1) ds
		work ctx = runCDoc (f ds) ctx
```

These two roles are somewhat orthogonal. We don't really expect to want the second usecase while printing a large tree, and we don't really expect lists of of messages to contain large trees. We don't really expect to be printing large trees in `UserStyle` at all, really. But we do expect to print _lots_ of potentially large lists - the context stack for where typechecking errors occur!

### Note on `Settings`

We will continue to add utility functions to this module as we find that we use them frequently. Don't be afraid to add more! The idea is to avoid breaking the abstraction that `CDoc` provides, which is that you shouldn't have to worry about the details of the `Settings` or style unless you want to.

`Settings` isn't specific to this module. It's the general record that contains all of the compilation flags and other settings for the current run of the compiler. There's not really anything substantial there right now so I'm not discussing the module, but it's in the source code. All of the flags that are declared there are placeholders!

[^1]: empty, char, text, int, integer, float, double, rational, parens, braces, brackets, doubleQuotes, nest, (<+>), (\$\$), (\$+\$), hcat, hsep, vcat, sep, cat, fsep, fcat.
[^2]: `;` `,` `:` `::` `=` `_` `.` `|` `->` `=>` `<-` `(` `)` `[` `]` `{` `}` `\` `' '` (space) ` ` (blank line).
